<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/previews/PR4/libs/katex/katex.min.css"> <link rel=stylesheet  href="/previews/PR4/libs/highlight/github.min.css"> <link rel=stylesheet  href="/previews/PR4/css/franklin.css"> <link rel=stylesheet  href="/previews/PR4/css/poole_hyde.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/previews/PR4/assets/favicon.png"> <title>Creating a JSO-compliant solver</title> <link rel=stylesheet  href="/previews/PR4/css/custom.css"> <link rel=preconnect  href="https://fonts.gstatic.com"> <link href="https://fonts.googleapis.com/css2?family=Nunito&family=Montserrat&display=swap" rel=stylesheet > <!--TODO: Add EVERYTHING-->> <script> hljs.getLanguage('julia').keywords.custom = 'obj grad hess AbstractNLPModel'; </script>" <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <img src="/previews/PR4/assets/jso.png"> <h1><a href="/previews/PR4/">JSO</a></h1> <p class=lead >Julia Smooth Optimizers.</p> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/previews/PR4/">Home</a> <a class="sidebar-nav-item " href="/previews/PR4/pages/tutorials/list/">Tutorials</a> <a class="sidebar-nav-item " href="/previews/PR4/pages/ecosystem/list/">Ecosystems</a> <a class="sidebar-nav-item " href="/previews/PR4/pages/how-to/list/">How-to guide</a> <a class="sidebar-nav-item " href="/previews/PR4/pages/reference/list/">Reference guides</a> </nav> <p>&copy; Abel Soares Siqueira.</p> </div> </div> <div class="content container"> <div class=franklin-content ><h1 id=title ><a href="#title" class=header-anchor >Creating a JSO-compliant solver</a></h1> <div class=author >by Abel S. Siqueira and João Okimoto</div> <p>In this tutorial you will learn what is a JSO-compliant solver, how to create one, and how to benchmark it against some other solver.</p> <div class=franklin-toc ><ol><li><a href="#what_is_a_jso-compliant_solver">What is a JSO-compliant solver</a><li><a href="#method_description">Method description</a><li><a href="#defining_a_test_problem_with_adnlpmodels_and_accessing_its_functions_with_the_nlpmodels_api">Defining a test problem with ADNLPModels and accessing its functions with the NLPModels API</a><li><a href="#improving_the_solver">Improving the solver</a><li><a href="#benchmarking">Benchmarking</a><li><a href="#performance_profiles">Performance profiles</a><li><a href="#improving_the_solver_more">Improving the solver more</a></ol></div> <h2 id=what_is_a_jso-compliant_solver ><a href="#what_is_a_jso-compliant_solver" class=header-anchor >What is a JSO-compliant solver</a></h2> <p>A JSO-compliant solver is a solver whose</p> <ul> <li><p>input is a model implementing the NLPModels API; and</p> <li><p>output is a specific struct from the package SolverTools.</p> </ul> <p>That means that you can devise your solver based on a single API that will work with many different problems. Furthermore, since the output type is known, we can provide tools to compare different solvers.</p> <p>To illustrate the procedure for creating a solver with the JSO API, we&#39;ll implement a Line-Search Modified Newton solver for the problem</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><munder><mo><mi>min</mi><mo>⁡</mo></mo><mi>x</mi></munder><mtext> </mtext><mi>f</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex"> \min_x \ f(x) </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.45em;vertical-align:-0.7em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.66786em;"><span style="top:-2.4em;margin-left:0em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span><span style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span><span class=mop >min</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.7em;"><span></span></span></span></span></span><span class=mspace > </span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span></span></span></span></span> <h2 id=method_description ><a href="#method_description" class=header-anchor >Method description</a></h2> <p>The method consists of following the direction <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_k</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">d</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> that solves</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><msup><mi mathvariant=normal >∇</mi><mn>2</mn></msup><mi>f</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy=false >)</mo><msub><mi>d</mi><mi>k</mi></msub><mo>=</mo><mo>−</mo><mi mathvariant=normal >∇</mi><mi>f</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex"> \nabla^2 f(x_k) d_k = -\nabla f(x_k) </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class=mord ><span class=mord >∇</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mord ><span class="mord mathnormal">d</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >−</span><span class=mord >∇</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span></span> <p>This is only reasonable if the system can be solved and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_k</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">d</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is a descent direction. A sufficient condition for that is that <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant=normal >∇</mi><mn>2</mn></msup><mi>f</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">\nabla^2 f(x_k)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.064108em;vertical-align:-0.25em;"></span><span class=mord ><span class=mord >∇</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> is positive definite, which is equivalent to saying that it has a Cholesky decomposition.</p> <p>Since this will not be true in general, the modified Newton method consists of computing <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ρ</mi><mi>k</mi></msub><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\rho_k \geq 0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class=mord ><span class="mord mathnormal">ρ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >≥</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0</span></span></span></span> such that <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant=normal >∇</mi><mn>2</mn></msup><mi>f</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy=false >)</mo><mo>+</mo><msub><mi>ρ</mi><mi>k</mi></msub><mi>I</mi></mrow><annotation encoding="application/x-tex">\nabla^2 f(x_k) + \rho_k I</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.064108em;vertical-align:-0.25em;"></span><span class=mord ><span class=mord >∇</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class=mord ><span class="mord mathnormal">ρ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> is positive definite. One way to find such a <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ρ</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\rho_k</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class=mord ><span class="mord mathnormal">ρ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is given below</p> <pre><code class="julia hljs"><span class=hljs-number >1.</span> Start with ρ from the last iteration
<span class=hljs-number >2.</span> Try to compute the Cholesky factor of ∇²f(x) + ρI
<span class=hljs-number >3.</span> If not successful, increase ρ to either <span class=hljs-number >1e-8</span> or <span class=hljs-number >10</span>ρ, whichever is largest, and <span class=hljs-keyword >return</span> to step <span class=hljs-number >2</span>
<span class=hljs-number >4.</span> Otherwise, <span class=hljs-keyword >continue</span> the algorithm</code></pre> <p>Next, for the line-search part, we use backtracking and ask that the Armijo condition be satisfied, that is find the smallest <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∈</mo><mi mathvariant=double-struck >N</mi></mrow><annotation encoding="application/x-tex">p \in \mathbb{N}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.68889em;vertical-align:0em;"></span><span class=mord ><span class="mord mathbb">N</span></span></span></span></span> such that <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><msup><mi>σ</mi><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">t = σ^p</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.664392em;vertical-align:0em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span> satisfies</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>f</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mi>k</mi></msub><mo>+</mo><mi>t</mi><msub><mi>d</mi><mi>k</mi></msub><mo stretchy=false >)</mo><mo>&lt;</mo><mi>f</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy=false >)</mo><mo>+</mo><mi>α</mi><mi>t</mi><msubsup><mi>g</mi><mi>k</mi><mi>T</mi></msubsup><msub><mi>d</mi><mi>k</mi></msub><mo separator=true >,</mo></mrow><annotation encoding="application/x-tex"> f(x_k + td_k) &lt; f(x_k) + \alpha t g_k^T d_k, </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class=mord ><span class="mord mathnormal">d</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >&lt;</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1.138331em;vertical-align:-0.247em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">t</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.247em;"><span></span></span></span></span></span></span><span class=mord ><span class="mord mathnormal">d</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span></span></span></span></span> <p>for <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>∈</mo><mo stretchy=false >(</mo><mn>0</mn><mo separator=true >,</mo><mn>1</mn><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">\alpha \in (0,1)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord >0</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >1</span><span class=mclose >)</span></span></span></span>, called the Armijo parameter.</p> <h2 id=defining_a_test_problem_with_adnlpmodels_and_accessing_its_functions_with_the_nlpmodels_api ><a href="#defining_a_test_problem_with_adnlpmodels_and_accessing_its_functions_with_the_nlpmodels_api" class=header-anchor >Defining a test problem with ADNLPModels and accessing its functions with the NLPModels API</a></h2> <p>Let&#39;s define a test problem to verify that our method is working, and let&#39;s use a classic one: Rosenbrock&#39;s function<sup id="fnref:1"><a href="#fndef:1" class=fnref >[1]</a></sup></p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><munder><mo><mi>min</mi><mo>⁡</mo></mo><mi>x</mi></munder><mtext> </mtext><mo stretchy=false >(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><mn>1</mn><msup><mo stretchy=false >)</mo><mn>2</mn></msup><mo>+</mo><mn>4</mn><mo stretchy=false >(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msubsup><mi>x</mi><mn>1</mn><mn>2</mn></msubsup><msup><mo stretchy=false >)</mo><mn>2</mn></msup><mo separator=true >,</mo></mrow><annotation encoding="application/x-tex"> \min_x \ (x_1 - 1)^2 + 4 (x_2 - x_1^2)^2, </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.45em;vertical-align:-0.7em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.66786em;"><span style="top:-2.4em;margin-left:0em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span><span style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span><span class=mop >min</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.7em;"><span></span></span></span></span></span><span class=mspace > </span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class=mord >1</span><span class=mclose ><span class=mclose >)</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >4</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.247em;"><span></span></span></span></span></span></span><span class=mclose ><span class=mclose >)</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mpunct >,</span></span></span></span></span> <p>starting from point &#91;-1.2; 1.0&#93;.</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> Plots
gr(size=(<span class=hljs-number >600</span>,<span class=hljs-number >300</span>))
contour(-<span class=hljs-number >2</span>:<span class=hljs-number >0.02</span>:<span class=hljs-number >2</span>, -<span class=hljs-number >0.5</span>:<span class=hljs-number >0.02</span>:<span class=hljs-number >1.5</span>, (x,y) -&gt; (x - <span class=hljs-number >1</span>)^<span class=hljs-number >2</span> + <span class=hljs-number >4</span> * (y - x^<span class=hljs-number >2</span>)^<span class=hljs-number >2</span>, levels=(<span class=hljs-number >0</span>:<span class=hljs-number >0.2</span>:<span class=hljs-number >10</span>).^<span class=hljs-number >2</span>)</code></pre> <img src="/previews/PR4/assets/pages/tutorials/creating-a-jso-compliant-solver/code/output/prob1.png" alt="Contour plot of objective"> <p>Notice that the solution of the problem, i.e., the point at which the function is minimum, is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mo stretchy=false >(</mo><mn>1</mn><mo separator=true >,</mo><mn>1</mn><msup><mo stretchy=false >)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">x = (1,1)^T</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord >1</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >1</span><span class=mclose ><span class=mclose >)</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>. This can be estimated by the plot and verified by noticing that <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy=false >(</mo><mn>1</mn><mo separator=true >,</mo><mn>1</mn><mo stretchy=false >)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(1,1) = 0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class=mord >1</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >1</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(x) &gt; 0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >&gt;</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0</span></span></span></span> for any other point.</p> <p>To write this problem as a NLPModel, we have a few options, but for now let&#39;s consider the simplest one: ADNLPModels. ADNLPModels has a simple interface and it computes the derivatives using automatic differentiation from other packages.</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> ADNLPModels

nlp = ADNLPModel(
  x -&gt; (x[<span class=hljs-number >1</span>] - <span class=hljs-number >1</span>)^<span class=hljs-number >2</span> + <span class=hljs-number >4</span> * (x[<span class=hljs-number >2</span>] - x[<span class=hljs-number >1</span>]^<span class=hljs-number >2</span>)^<span class=hljs-number >2</span>, <span class=hljs-comment ># function</span>
  [-<span class=hljs-number >1.2</span>; <span class=hljs-number >1.0</span>] <span class=hljs-comment ># starting point</span>
)</code></pre><pre><code class="plaintext hljs">ADNLPModel - Model with automatic differentiation
  Problem name: Generic
   All variables: ████████████████████ 2      All constraints: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
            free: ████████████████████ 2                 free: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
           lower: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                lower: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
           upper: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                upper: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
         low/upp: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0              low/upp: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
           fixed: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                fixed: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
          infeas: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0               infeas: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
            nnzh: (  0.00% sparsity)   3               linear: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
                                                    nonlinear: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
                                                         nnzj: (------% sparsity)         

  Counters:
             obj: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                 grad: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                 cons: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
            jcon: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                jgrad: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                  jac: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
           jprod: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0               jtprod: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                 hess: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
           hprod: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0               jhprod: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
</code></pre> <p>Now we access the information of the model, and its functions. The information is all stored on <code>nlp.meta</code>, while the functions are defined by NLPModels.</p> <p>The main information you may want is summarised below</p> <pre><code class="julia hljs">(
  nlp.meta.nvar, <span class=hljs-comment ># number of variable</span>
  nlp.meta.ncon, <span class=hljs-comment ># number of constraints</span>
  nlp.meta.lvar, nlp.meta.uvar, <span class=hljs-comment ># bounds on variables</span>
  nlp.meta.lcon, nlp.meta.ucon, <span class=hljs-comment ># bounds on constraints</span>
  nlp.meta.x0 <span class=hljs-comment ># starting point</span>
)</code></pre><pre><code class="plaintext hljs">(2, 0, [-Inf, -Inf], [Inf, Inf], Float64[], Float64[], [-1.2, 1.0])</code></pre>
<p>Furthermore, you can use some functions from NLPModels to query whether the problem has bounds, equalities, inequalities, etc.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> NLPModels

unconstrained(nlp)</code></pre><pre><code class="plaintext hljs">true</code></pre>
<p>Finally, we can access the objective function, its gradients and Hessian with</p>
<pre><code class="julia hljs">x = nlp.meta.x0
obj(nlp, x)</code></pre><pre><code class="plaintext hljs">5.614400000000001</code></pre>
<pre><code class="julia hljs">grad(nlp, x)</code></pre><pre><code class="plaintext hljs">2-element Array{Float64,1}:
 -12.847999999999999
  -3.5199999999999996</code></pre>
<pre><code class="julia hljs">hess(nlp, x)</code></pre><pre><code class="plaintext hljs">2×2 Array{Float64,2}:
 55.12  0.0
 19.2   8.0</code></pre>
<p>For our basic unconstrained solver that&#39;s enough. If you want more functions, check the <a href="/previews/PR4/pages/references/NLPModels/">NLPModels reference guide</a>.</p>
<p>Notice that the Hessian returned from <code>hess</code> has only the lower triangle. That&#39;s done, in general, to avoid storing repeated elements. In this dense case, this isn&#39;t much helpful, so we can simply use <code>Symmetric</code> to fill the rest.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> LinearAlgebra

Symmetric(hess(nlp, x), :L)</code></pre><pre><code class="plaintext hljs">2×2 LinearAlgebra.Symmetric{Float64,Array{Float64,2}}:
 55.12  19.2
 19.2    8.0</code></pre>
<p>To compute Cholesky and verify that it succeeds, we use <code>cholesky</code> and <code>issuccess</code>.</p>
<pre><code class="julia hljs">B = Symmetric(hess(nlp, x), :L)
factor = cholesky(B, check=<span class=hljs-literal >false</span>) <span class=hljs-comment ># check is false to prevent an error from being thrown.</span>
issuccess(factor)</code></pre><pre><code class="plaintext hljs">true</code></pre>
<pre><code class="julia hljs">B = -Symmetric(hess(nlp, x), :L) <span class=hljs-comment ># Since the last one is positive definite, this one shouldn&#x27;t be</span>
factor = cholesky(B, check=<span class=hljs-literal >false</span>)
issuccess(factor)</code></pre><pre><code class="plaintext hljs">false</code></pre>
<p>Therefore the direction computation can be done as</p>
<pre><code class="julia hljs">ρ = <span class=hljs-number >0.0</span> <span class=hljs-comment ># First iteration</span>

B = Symmetric(hess(nlp, x), :L)
factor = cholesky(B + ρ * I, check=<span class=hljs-literal >false</span>)
<span class=hljs-keyword >while</span> !issuccess(factor)
  ρ = max(<span class=hljs-number >1e-8</span>, <span class=hljs-number >10</span>ρ)
  factor = cholesky(B + ρ * I, check=<span class=hljs-literal >false</span>)
<span class=hljs-keyword >end</span>
d = factor \ -grad(nlp, x)</code></pre><pre><code class="plaintext hljs">2-element Array{Float64,1}:
  0.4867256637168144
 -0.7281415929203545</code></pre>
<p>The second part of our method is the step length computation. Let&#39;s use <code>α &#61; 1e-2</code> for our Armijo parameter.</p>
<pre><code class="julia hljs">α = <span class=hljs-number >1e-2</span>
t = <span class=hljs-number >1.0</span>
fx = obj(nlp, x)
ft = obj(nlp, x + t * d)
slope = dot(grad(nlp, x), d)
<span class=hljs-keyword >while</span> !(ft ≤ fx + t * slope)
  <span class=hljs-keyword >global</span> t *= <span class=hljs-number >0.5</span> <span class=hljs-comment ># global is used because we are outside a function</span>
  ft = obj(nlp, x + t * d)
<span class=hljs-keyword >end</span></code></pre>
<p>The two snippets above are what define our method. We&#39;ll use the first order criteria for stopping the algorithm, that is</p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi mathvariant=normal >∥</mi><mi mathvariant=normal >∇</mi><mi>f</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy=false >)</mo><mi mathvariant=normal >∥</mi><mo>&lt;</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex"> \| \nabla f(x_k) \| &lt; \epsilon </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >∥</span><span class=mord >∇</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mord >∥</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >&lt;</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span></span>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> SolverTools

<span class=hljs-keyword >function</span> newton(nlp :: AbstractNLPModel)

  x = copy(nlp.meta.x0) <span class=hljs-comment ># starting point</span>
  α = <span class=hljs-number >1e-2</span> <span class=hljs-comment ># Armijo parameter</span>
  ρ = <span class=hljs-number >0.0</span>

  <span class=hljs-keyword >while</span> norm(grad(nlp, x)) &gt; <span class=hljs-number >1e-6</span>

    <span class=hljs-comment ># Computing the direction</span>
    B = Symmetric(hess(nlp, x), :L)
    factor = cholesky(B + ρ * I, check=<span class=hljs-literal >false</span>)
    <span class=hljs-keyword >while</span> !issuccess(factor)
      ρ = max(<span class=hljs-number >1e-8</span>, <span class=hljs-number >10</span>ρ)
      factor = cholesky(B + ρ * I, check=<span class=hljs-literal >false</span>)
    <span class=hljs-keyword >end</span>
    d = factor \ -grad(nlp, x)

    <span class=hljs-comment ># Computing the step length</span>
    t = <span class=hljs-number >1.0</span>
    fx = obj(nlp, x)
    ft = obj(nlp, x + t * d)
    slope = dot(grad(nlp, x), d)
    <span class=hljs-keyword >while</span> !(ft ≤ fx + α * t * slope)
      t *= <span class=hljs-number >0.5</span>
      ft = obj(nlp, x + t * d)
    <span class=hljs-keyword >end</span>

    x += t * d
  <span class=hljs-keyword >end</span>

  status = :first_order

  <span class=hljs-keyword >return</span> GenericExecutionStats(status, nlp)

<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">newton (generic function with 1 method)</code></pre>
<p>Notice the two conditions for the method to be JSO-compliant:</p>
<ul>
<li><p>Input is a NLPModel - Namely, an <code>AbstractNLPModel</code>:</p>

</ul>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> newton(nlp :: AbstractNLPModel)</code></pre>
<ul>
<li><p>output is a specific struct from the package SolverTools - Namely, a <code>GenericExecutionStats</code>:</p>

</ul>
<pre><code class="julia hljs"><span class=hljs-keyword >return</span> GenericExecutionStats(status, nlp)</code></pre>
<p>For this structure to be used, a <code>status</code> argument needs to be passed, indicating what&#39;s the situation of the solver run. We passed a <code>:first_order</code> value, indicating that a first order solution was found. More about this later.</p>
<p>The NLPModels API provides you with the derivatives, and anything else can reside inside the function, and there is where the magic happens.</p>
<p>Let&#39;s run our implementation on the problem we defined before.</p>
<pre><code class="julia hljs">output = newton(nlp)

println(output)</code></pre><pre><code class="plaintext hljs">Generic Execution stats
  status: first-order stationary
  objective value: Inf
  primal feasibility: 0.0
  dual feasibility: Inf
  solution: ∅
  iterations: -1
  elapsed time: Inf
</code></pre>
<p>The <code>GenericExecutionStats</code> structure holds all relevant information. Notice, however, that it doesn&#39;t have anything useful in this case. Naturally, we have to return that information as well.</p>
<p>Update your <code>newton</code> function so that the end is something like the following.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> newton(nlp :: AbstractNLPModel)
  <span class=hljs-comment ># …</span>

  <span class=hljs-keyword >return</span> GenericExecutionStats(status, nlp, solution=x, objective=obj(nlp, x))
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">newton (generic function with 1 method)</code></pre>
<p>Now run again</p>
<pre><code class="julia hljs">output = newton(nlp)

println(output)</code></pre><pre><code class="plaintext hljs">Generic Execution stats
  status: first-order stationary
  objective value: 7.141610295610004e-18
  primal feasibility: 0.0
  dual feasibility: Inf
  solution: [0.9999999973418803  0.9999999945459112]
  iterations: -1
  elapsed time: Inf
</code></pre>
<p>That&#39;s already better. Now we can access the solution with</p>
<pre><code class="julia hljs">output.solution</code></pre><pre><code class="plaintext hljs">2-element Array{Float64,1}:
 0.9999999973418803
 0.9999999945459112</code></pre>
<h2 id=improving_the_solver ><a href="#improving_the_solver" class=header-anchor >Improving the solver</a></h2>
<p>Although we have an implementation of our method, it has a few shortcomings, which we must address before continuing. Mainly, our solver needs a better handling of the stopping conditions. Currently, we only stop when the first order condition <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >∥</mi><mi mathvariant=normal >∇</mi><mi>f</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy=false >)</mo><mi mathvariant=normal >∥</mi><mo>&lt;</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\|\nabla f(x_k)\| &lt; \epsilon</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >∥</span><span class=mord >∇</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mord >∥</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >&lt;</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> is satisfied. Although our method is good, this could fail to happen in a reasonable time, and therefore we have to define some stopping conditions to prevent an infinite loop.</p>
<p>The two main conditions we&#39;ll add are the number of iterations and elapsed time to be limited. In this case, the result of the solver run may no be a <code>:first_order</code> situation anymore, which means that we need to use other <code>status</code> value. Here&#39;s the list:</p>
<pre><code class="julia hljs">SolverTools.show_statuses()</code></pre><pre><code class="plaintext hljs">STATUSES:
  :acceptable     =&gt; solved to within acceptable tolerances
  :exception      =&gt; unhandled exception
  :first_order    =&gt; first-order stationary
  :infeasible     =&gt; problem may be infeasible
  :max_eval       =&gt; maximum number of function evaluations
  :max_iter       =&gt; maximum iteration
  :max_time       =&gt; maximum elapsed time
  :neg_pred       =&gt; negative predicted reduction
  :not_desc       =&gt; not a descent direction
  :small_residual =&gt; small residual
  :small_step     =&gt; step too small
  :stalled        =&gt; stalled
  :unbounded      =&gt; objective function may be unbounded from below
  :unknown        =&gt; unknown
  :user           =&gt; user-requested stop
</code></pre>
<p>We can see that <code>max_iter</code> and <code>max_time</code> are the most adequates for our case.</p>
<p>In addition, the maximum amount of time and iterations that the solver can execute are usually arguments passed to the solver. Since the only mandatory argument must be the model, we can use optional arguments. We prefer to use keywords.</p>
<p>Change your code considering the changes below:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> newton(
  nlp :: AbstractNLPModel; <span class=hljs-comment ># Only mandatory argument, notice the ;</span>
  max_time :: <span class=hljs-built_in >Float64</span> = <span class=hljs-number >30.0</span>, <span class=hljs-comment ># maximum allowed time</span>
  max_iter :: <span class=hljs-built_in >Int</span> = <span class=hljs-number >100</span> <span class=hljs-comment ># maximum allowed iterations</span>
)
  <span class=hljs-comment ># …</span>
  iter = <span class=hljs-number >0</span>
  t₀ = time()
  Δt = time() - t₀
  status = :unknown
  tired = Δt ≥ max_time &gt; <span class=hljs-number >0</span> || iter ≥ max_iter &gt; <span class=hljs-number >0</span>
  solved = norm(grad(nlp, x)) ≤ <span class=hljs-number >1e-6</span>
  <span class=hljs-keyword >while</span> !(solved || tired)
    <span class=hljs-comment ># …</span>
    iter += <span class=hljs-number >1</span>
    Δt = time() - t₀
    tired = Δt ≥ max_time &gt; <span class=hljs-number >0</span> || iter ≥ max_iter &gt; <span class=hljs-number >0</span>
    solved = norm(grad(nlp, x)) ≤ <span class=hljs-number >1e-6</span>
  <span class=hljs-keyword >end</span>
  <span class=hljs-keyword >if</span> solved
    status = :first_order
  <span class=hljs-keyword >elseif</span> tired
    <span class=hljs-keyword >if</span> Δt ≥ max_time &gt; <span class=hljs-number >0</span>
      status = :max_time
    <span class=hljs-keyword >elseif</span> iter ≥ max_iter &gt; <span class=hljs-number >0</span>
      status = :max_iter
    <span class=hljs-keyword >end</span>
  <span class=hljs-keyword >end</span>

  <span class=hljs-keyword >return</span> GenericExecutionStats(status, nlp, solution=x, objective=obj(nlp, x), iter=iter, elapsed_time=Δt)
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">newton (generic function with 1 method)</code></pre>
<p>Many of the lines are self-explanatory, so let&#39;s focus on the complex ones.</p>
<pre><code class="julia hljs">tired = Δt ≥ max_time &gt; <span class=hljs-number >0</span> || iter ≥ max_iter &gt; <span class=hljs-number >0</span>
solved = norm(grad(nlp, x)) ≤ <span class=hljs-number >1e-6</span>
<span class=hljs-keyword >while</span> !(solved || tired)</code></pre>
<p>Both <code>tired</code> and <code>solved</code> are Boolean indicators, that is, they are true to indicate that a certain situation has happened.</p>
<p>The variable <code>tired</code> is true if the elapsed time surpass the maximum time or if the number of iterations surpass the maximum of iterations. We also allow for the case of &quot;turning off&quot; the check by setting the corresponding maximum to 0 or a negative number.</p>
<p>The variable <code>solved</code> is true if the the point satisfies the first order condition.</p>
<p>The conditional at the end verifies these conditions and set the appropriate <code>status</code>.   Notice that we set the <code>status</code> to <code>:unknown</code> at the beginning, both for the good practice of having a default value, but also because if the code returns the <code>:unknown</code> status, we <strong>really</strong> don&#39;t know what happened.</p>
<h2 id=benchmarking ><a href="#benchmarking" class=header-anchor >Benchmarking</a></h2>
<p>With a solver in hands, we can start to do more advanced things, such as benchmarking and comparing our <code>newton</code> method to other solvers.</p>
<p>Since we only implemented one solved, we&#39;ll use <code>lbfgs</code> from the package JSOSolvers to compare against.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> JSOSolvers

output = lbfgs(nlp)
print(output)</code></pre><pre><code class="plaintext hljs">Generic Execution stats
  status: first-order stationary
  objective value: 2.239721910559509e-18
  primal feasibility: 0.0
  dual feasibility: 4.018046284781729e-9
  solution: [0.9999999986742657  0.9999999970013461]
  iterations: 18
  elapsed time: 0.6840689182281494
</code></pre>
<p>And to compare both solvers, we need a collection of problems. Let&#39;s just create one manually for now.</p>
<pre><code class="julia hljs">problems = [
  ADNLPModel(x -&gt; x[<span class=hljs-number >1</span>]^<span class=hljs-number >2</span> + <span class=hljs-number >4</span> * x[<span class=hljs-number >2</span>]^<span class=hljs-number >2</span>, ones(<span class=hljs-number >2</span>)),
  ADNLPModel(x -&gt; (<span class=hljs-number >1</span> - x[<span class=hljs-number >1</span>])^<span class=hljs-number >2</span> + <span class=hljs-number >100</span> * (x[<span class=hljs-number >2</span>] - x[<span class=hljs-number >1</span>]^<span class=hljs-number >2</span>)^<span class=hljs-number >2</span>, [-<span class=hljs-number >1.2</span>; <span class=hljs-number >1.0</span>]),
  ADNLPModel(x -&gt; x[<span class=hljs-number >1</span>]^<span class=hljs-number >2</span> + x[<span class=hljs-number >2</span>] - <span class=hljs-number >11</span> + (x[<span class=hljs-number >1</span>] + x[<span class=hljs-number >2</span>]^<span class=hljs-number >2</span> - <span class=hljs-number >7</span>)^<span class=hljs-number >2</span>, [-<span class=hljs-number >1.0</span>; <span class=hljs-number >1.0</span>]),
  ADNLPModel(x -&gt; log(exp(-x[<span class=hljs-number >1</span>] - <span class=hljs-number >2</span>x[<span class=hljs-number >2</span>]) + exp(x[<span class=hljs-number >1</span>] + <span class=hljs-number >2</span>) + exp(<span class=hljs-number >2</span>x[<span class=hljs-number >2</span>] - <span class=hljs-number >1</span>)), zeros(<span class=hljs-number >2</span>))
];</code></pre>
<p>And now, we use <code>bmark_solvers</code> from the package SolverBenchmark to automatically run both solvers on all these problems.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> SolverBenchmark

solvers = <span class=hljs-built_in >Dict</span>(:newton =&gt; newton, :lbfgs =&gt; lbfgs)
stats = bmark_solvers(solvers, problems)</code></pre><pre><code class="plaintext hljs">Dict{Symbol,DataFrames.DataFrame} with 2 entries:
  :newton =&gt; 4×30 DataFrame
│ Row │ id    │ name    │ nvar  │ ncon  │ nequ  │ status      │ objective   │ elapsed_time │ iter  │ dual_feas │ primal_feas │ neval_obj │ neval_grad │ neval_cons │ neval_jcon │ neval_jgrad │ neval_jac │ neval_jprod │ neval_jtprod │ neval_hess │ neval_hprod │ neval_jhprod │ neval_residual │ neval_jac_residual │ neval_jprod_residual │ neval_jtprod_residual │ neval_hess_residual │ neval_jhess_residual │ neval_hprod_residual │ extrainfo │
│     │ Int64 │ String  │ Int64 │ Int64 │ Int64 │ Symbol      │ Float64     │ Float64      │ Int64 │ Float64   │ Float64     │ Int64     │ Int64      │ Int64      │ Int64      │ Int64       │ Int64     │ Int64       │ Int64        │ Int64      │ Int64       │ Int64        │ Int64          │ Int64              │ Int64                │ Int64                 │ Int64               │ Int64                │ Int64                │ String    │
├─────┼───────┼─────────┼───────┼───────┼───────┼─────────────┼─────────────┼──────────────┼───────┼───────────┼─────────────┼───────────┼────────────┼────────────┼────────────┼─────────────┼───────────┼─────────────┼──────────────┼────────────┼─────────────┼──────────────┼────────────────┼────────────────────┼──────────────────────┼───────────────────────┼─────────────────────┼──────────────────────┼──────────────────────┼───────────┤
│ 1   │ 1     │ Generic │ 2     │ 0     │ 0     │ first_order │ 2.46519e-31 │ 0.462111     │ 1     │ Inf       │ 0.0         │ 3         │ 4          │ 0          │ 0          │ 0           │ 0         │ 0           │ 0            │ 1          │ 0           │ 0            │ 0              │ 0                  │ 0                    │ 0                     │ 0                   │ 0                    │ 0                    │           │
│ 2   │ 2     │ Generic │ 2     │ 0     │ 0     │ first_order │ 3.74398e-21 │ 0.599064     │ 21    │ Inf       │ 0.0         │ 50        │ 64         │ 0          │ 0          │ 0           │ 0         │ 0           │ 0            │ 21         │ 0           │ 0            │ 0              │ 0                  │ 0                    │ 0                     │ 0                   │ 0                    │ 0                    │           │
│ 3   │ 3     │ Generic │ 2     │ 0     │ 0     │ max_iter    │ -8.36356    │ 0.469352     │ 100   │ Inf       │ 0.0         │ 201       │ 301        │ 0          │ 0          │ 0           │ 0         │ 0           │ 0            │ 100        │ 0           │ 0            │ 0              │ 0                  │ 0                    │ 0                     │ 0                   │ 0                    │ 0                    │           │
│ 4   │ 4     │ Generic │ 2     │ 0     │ 0     │ first_order │ 1.43195     │ 0.486029     │ 5     │ Inf       │ 0.0         │ 12        │ 16         │ 0          │ 0          │ 0           │ 0         │ 0           │ 0            │ 5          │ 0           │ 0            │ 0              │ 0                  │ 0                    │ 0                     │ 0                   │ 0                    │ 0                    │           │
  :lbfgs =&gt; 4×30 DataFrame
│ Row │ id    │ name    │ nvar  │ ncon  │ nequ  │ status      │ objective   │ elapsed_time │ iter  │ dual_feas  │ primal_feas │ neval_obj │ neval_grad │ neval_cons │ neval_jcon │ neval_jgrad │ neval_jac │ neval_jprod │ neval_jtprod │ neval_hess │ neval_hprod │ neval_jhprod │ neval_residual │ neval_jac_residual │ neval_jprod_residual │ neval_jtprod_residual │ neval_hess_residual │ neval_jhess_residual │ neval_hprod_residual │ extrainfo │
│     │ Int64 │ String  │ Int64 │ Int64 │ Int64 │ Symbol      │ Float64     │ Float64      │ Int64 │ Float64    │ Float64     │ Int64     │ Int64      │ Int64      │ Int64      │ Int64       │ Int64     │ Int64       │ Int64        │ Int64      │ Int64       │ Int64        │ Int64          │ Int64              │ Int64                │ Int64                 │ Int64               │ Int64                │ Int64                │ String    │
├─────┼───────┼─────────┼───────┼───────┼───────┼─────────────┼─────────────┼──────────────┼───────┼────────────┼─────────────┼───────────┼────────────┼────────────┼────────────┼─────────────┼───────────┼─────────────┼──────────────┼────────────┼─────────────┼──────────────┼────────────────┼────────────────────┼──────────────────────┼───────────────────────┼─────────────────────┼──────────────────────┼──────────────────────┼───────────┤
│ 1   │ 1     │ Generic │ 2     │ 0     │ 0     │ first_order │ 2.26824e-16 │ 0.000183821  │ 8     │ 5.28297e-8 │ 0.0         │ 11        │ 10         │ 0          │ 0          │ 0           │ 0         │ 0           │ 0            │ 0          │ 0           │ 0            │ 0              │ 0                  │ 0                    │ 0                     │ 0                   │ 0                    │ 0                    │           │
│ 2   │ 2     │ Generic │ 2     │ 0     │ 0     │ first_order │ 1.44561e-17 │ 0.000196218  │ 39    │ 8.41132e-8 │ 0.0         │ 52        │ 45         │ 0          │ 0          │ 0           │ 0         │ 0           │ 0            │ 0          │ 0           │ 0            │ 0              │ 0                  │ 0                    │ 0                     │ 0                   │ 0                    │ 0                    │           │
│ 3   │ 3     │ Generic │ 2     │ 0     │ 0     │ first_order │ -8.37235    │ 0.000106096  │ 12    │ 1.60958e-9 │ 0.0         │ 17        │ 15         │ 0          │ 0          │ 0           │ 0         │ 0           │ 0            │ 0          │ 0           │ 0            │ 0              │ 0                  │ 0                    │ 0                     │ 0                   │ 0                    │ 0                    │           │
│ 4   │ 4     │ Generic │ 2     │ 0     │ 0     │ first_order │ 1.43195     │ 0.000114918  │ 9     │ 4.18646e-9 │ 0.0         │ 11        │ 11         │ 0          │ 0          │ 0           │ 0         │ 0           │ 0            │ 0          │ 0           │ 0            │ 0              │ 0                  │ 0                    │ 0                     │ 0                   │ 0                    │ 0                    │           │</code></pre>
<p>The results is a Dictionary of Symbols to DataFrame tables.</p>
<pre><code class="julia hljs"><span class=hljs-meta >@show</span> typeof(stats)
<span class=hljs-meta >@show</span> keys(stats)</code></pre><pre><code class="plaintext hljs">typeof(stats) = Dict{Symbol,DataFrames.DataFrame}
keys(stats) = [:newton, :lbfgs]
</code></pre>
<p>Using SolverBenchmark, it&#39;s easy to create a markdown table from the results.</p>
<pre><code class="julia hljs">cols = [:name, :status, :objective, :elapsed_time, :iter]
pretty_stats(stats[:newton][cols])</code></pre><pre><code class="plaintext hljs">┌─────────┬─────────────┬───────────┬──────────────┬────────┐
│    name │      status │ objective │ elapsed_time │   iter │
├─────────┼─────────────┼───────────┼──────────────┼────────┤
│ Generic │ first_order │  2.47e-31 │     4.62e-01 │      1 │
│ Generic │ first_order │  3.74e-21 │     5.99e-01 │     21 │
│ Generic │    max_iter │ -8.36e+00 │     4.69e-01 │    100 │
│ Generic │ first_order │  1.43e+00 │     4.86e-01 │      5 │
└─────────┴─────────────┴───────────┴──────────────┴────────┘
</code></pre>
<p>We can also create a similar table in .tex format, using something like</p>
<pre><code class="julia hljs">open(<span class=hljs-string >&quot;newton.tex&quot;</span>, <span class=hljs-string >&quot;w&quot;</span>) <span class=hljs-keyword >do</span> io
  pretty_latex_stats(io, stats[:newton][cols])
<span class=hljs-keyword >end</span></code></pre>
<p>That will give us a nicely formatted table that we can just plug into our latex code.</p>
<h2 id=performance_profiles ><a href="#performance_profiles" class=header-anchor >Performance profiles</a></h2>
<p>Lastly, for comparison of the methods, it is costumary to show a Performance Profile.<sup id="fnref:2"><a href="#fndef:2" class=fnref >[2]</a></sup> Internally we use the package BenchmarkProfiles, though using <code>performance_profile</code> from SolverBenchmark will actually work directly with the output of <code>bmark_solvers</code>.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Plots
performance_profile(stats, df -&gt; df.elapsed_time)</code></pre>
<img src="/previews/PR4/assets/pages/tutorials/creating-a-jso-compliant-solver/code/output/perfprof.png" alt="Performance profile">
<p>Notice how the profile indicate that all problems were solved by <code>newton</code>, although it is clearly not the case. That happens because our cost function for the performance profile was only the elapsed time. A better approach would be something like.</p>
<pre><code class="julia hljs">cost(df) = (df.status .!= :first_order) * <span class=hljs-literal >Inf</span> + df.elapsed_time
performance_profile(stats, cost)</code></pre>
<img src="/previews/PR4/assets/pages/tutorials/creating-a-jso-compliant-solver/code/output/perfprof2.png" alt="Performance profile">
<h2 id=improving_the_solver_more ><a href="#improving_the_solver_more" class=header-anchor >Improving the solver more</a></h2>
<p>Although we did implement the proposed method, we could improve the code a little bit. The following function is an improvement of the code in a few points:</p>
<ul>
<li><p>Reuse <code>obj&#40;nlp, x&#41;</code> and <code>grad&#40;nlp, x&#41;</code> when possible.</p>

<li><p>Stopping tolerances <code>atol</code> and <code>rtol</code> are used for a stopping criteria </p>

</ul>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi mathvariant=normal >∥</mi><mi mathvariant=normal >∇</mi><mi>f</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy=false >)</mo><mi mathvariant=normal >∥</mi><mo>≤</mo><msub><mi>ϵ</mi><mtext>absolute</mtext></msub><mo>+</mo><msub><mi>ϵ</mi><mtext>relative</mtext></msub><mi mathvariant=normal >∥</mi><mi mathvariant=normal >∇</mi><mi>f</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy=false >)</mo><mi mathvariant=normal >∥</mi></mrow><annotation encoding="application/x-tex"> \|\nabla f(x_k)\| \leq \epsilon_{\text{absolute}} + \epsilon_{\text{relative}}\| \nabla f(x_0)\| </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >∥</span><span class=mord >∇</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mord >∥</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >≤</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.73333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">ϵ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">absolute</span></span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord ><span class="mord mathnormal">ϵ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">relative</span></span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mord >∥</span><span class=mord >∇</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mord >∥</span></span></span></span></span>
<ul>
<li><p>After computing the direction, we reduce <code>ρ</code> to try to speed up the method.</p>

</ul>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> newton2(
  nlp :: AbstractNLPModel; <span class=hljs-comment ># Only mandatory argument</span>
  x :: <span class=hljs-built_in >AbstractVector</span> = copy(nlp.meta.x0), <span class=hljs-comment ># optimal starting point</span>
  atol :: <span class=hljs-built_in >Real</span> = <span class=hljs-number >1e-6</span>, <span class=hljs-comment ># absolute tolerance</span>
  rtol :: <span class=hljs-built_in >Real</span> = <span class=hljs-number >1e-6</span>, <span class=hljs-comment ># relative tolerance</span>
  max_time :: <span class=hljs-built_in >Float64</span> = <span class=hljs-number >30.0</span>, <span class=hljs-comment ># maximum allowed time</span>
  max_iter :: <span class=hljs-built_in >Int</span> = <span class=hljs-number >100</span> <span class=hljs-comment ># maximum allowed iterations</span>
)

  <span class=hljs-comment ># Initialization</span>
  fx = obj(nlp, x)
  ∇fx = grad(nlp, x)

  iter = <span class=hljs-number >0</span>
  Δt = <span class=hljs-number >0.0</span>
  t₀ = time()
  α = <span class=hljs-number >1e-2</span>
  ρ = <span class=hljs-number >0.0</span>
  status = :unknown
  ϵ = atol + rtol * norm(∇fx)

  tired = Δt ≥ max_time &gt; <span class=hljs-number >0</span> || iter ≥ max_iter &gt; <span class=hljs-number >0</span>
  optimal = norm(∇fx) &lt; ϵ

  <span class=hljs-keyword >while</span> !(optimal || tired) <span class=hljs-comment ># while not optimal or tired</span>

    B = Symmetric(hess(nlp, x), :L)
    factor = cholesky(B + ρ * I, check=<span class=hljs-literal >false</span>)
    <span class=hljs-keyword >while</span> !issuccess(factor)
      ρ = max(<span class=hljs-number >1e-8</span>, <span class=hljs-number >10</span>ρ)
      factor = cholesky(B + ρ * I, check=<span class=hljs-literal >false</span>)
    <span class=hljs-keyword >end</span>
    d = factor \ -grad(nlp, x)
    ρ = ρ / <span class=hljs-number >10</span>

    t = <span class=hljs-number >1.0</span>
    ft = obj(nlp, x + t * d)
    slope = dot(grad(nlp, x), d)
    <span class=hljs-keyword >while</span> !(ft ≤ fx + α * t * slope)
      t *= <span class=hljs-number >0.5</span>
      ft = obj(nlp, x + t * d)
    <span class=hljs-keyword >end</span>
    t

    x += t * d

    fx = obj(nlp, x)
    ∇fx = grad(nlp, x)

    iter += <span class=hljs-number >1</span>
    Δt = time() - t₀
    tired = Δt ≥ max_time &gt; <span class=hljs-number >0</span> || iter ≥ max_iter &gt; <span class=hljs-number >0</span>
    ϵ = atol + rtol * norm(∇fx)
    optimal = norm(∇fx) &lt; ϵ
  <span class=hljs-keyword >end</span>

  <span class=hljs-keyword >if</span> optimal
    status = :first_order
  <span class=hljs-keyword >elseif</span> tired
    <span class=hljs-keyword >if</span> iter ≥ max_iter &gt; <span class=hljs-number >0</span>
      status = :max_iter
    <span class=hljs-keyword >elseif</span> Δt ≥ max_time &gt; <span class=hljs-number >0</span>
      status = :max_time
    <span class=hljs-keyword >end</span>
  <span class=hljs-keyword >end</span>

  <span class=hljs-keyword >return</span> GenericExecutionStats(status, nlp, solution=x, objective=fx, dual_feas=norm(∇fx), iter=iter, elapsed_time=Δt)

<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">newton2 (generic function with 1 method)</code></pre>
<p>And now testing again.</p>
<pre><code class="julia hljs">solvers = <span class=hljs-built_in >Dict</span>(:newton =&gt; newton2, :lbfgs =&gt; lbfgs)
stats = bmark_solvers(solvers, problems)
cost(df) = (df.status .!= :first_order) * <span class=hljs-literal >Inf</span> + df.elapsed_time
performance_profile(stats, cost)</code></pre>
<img src="/previews/PR4/assets/pages/tutorials/creating-a-jso-compliant-solver/code/output/perfprof3.png" alt="Performance profile">
<p><table class=fndef  id="fndef:1">
    <tr>
        <td class=fndef-backref ><a href="#fnref:1">[1]</a>
        <td class=fndef-content >Technically, it can be defined more generally, but the choice we made has better behaved values. <a href="https://en.wikipedia.org/wiki/Rosenbrock_function#:~:text&#61;In&#37;20mathematical&#37;20optimization&#37;2C&#37;20the&#37;20Rosenbrock,valley&#37;20or&#37;20Rosenbrock&#37;27s&#37;20banana&#37;20function">Wikipedia page: Rosenbrock page, access on 2021/Mar/17.</a>
    
</table>
 <table class=fndef  id="fndef:2">
    <tr>
        <td class=fndef-backref ><a href="#fnref:2">[2]</a>
        <td class=fndef-content >Dolan, E., Moré, J. Benchmarking optimization software with performance profiles. Math. Program. 91, 201–213 &#40;2002&#41;. <a href="https://doi.org/10.1007/s101070100263">doi.org/10.1007/s101070100263</a>
    
</table>
</p>

<div class=page-foot >
  <div class=copyright >
    &copy; Abel Soares Siqueira. Last modified: March 18, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    </div>